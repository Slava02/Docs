<!doctype html><html class=no-js lang=ru><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=../../../../assets/images/favicon.png rel=icon><meta content="mkdocs-1.5.3, mkdocs-material-9.5.3" name=generator><title>Кеширование - Документация</title><link href=../../../../assets/stylesheets/main.50c56a3b.min.css rel=stylesheet><link href=../../../../assets/stylesheets/palette.06af60db.min.css rel=stylesheet><style>:root{--md-annotation-icon:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M22 12a10 10 0 0 1-10 10A10 10 0 0 1 2 12 10 10 0 0 1 12 2a10 10 0 0 1 10 10m-12 6 6-6-6-6-1.4 1.4 4.6 4.6-4.6 4.6L10 18Z"/></svg>');}</style><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback" rel=stylesheet><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link href=../../../../stylesheets/extra.css rel=stylesheet><script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><body data-md-color-accent=purple data-md-color-primary=deep-purple data-md-color-scheme=slate dir=ltr><input autocomplete=off class=md-toggle data-md-toggle=drawer id=__drawer type=checkbox><input autocomplete=off class=md-toggle data-md-toggle=search id=__search type=checkbox><label class=md-overlay for=__drawer></label><div data-md-component=skip><a class=md-skip href=#_1> Перейти к содержанию </a></div><div data-md-component=announce></div><header class="md-header md-header--shadow md-header--lifted" data-md-component=header><nav aria-label="Верхний колонтитул" class="md-header__inner md-grid"><a class="md-header__button md-logo" aria-label=Документация data-md-component=logo href=../../../.. title=Документация> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a><label class="md-header__button md-icon" for=__drawer><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg></label><div class=md-header__title data-md-component=header-title><div class=md-header__ellipsis><div class=md-header__topic><span class=md-ellipsis> Документация </span></div><div class=md-header__topic data-md-component=header-topic><span class=md-ellipsis> Кеширование </span></div></div></div><form class=md-header__option data-md-component=palette><input aria-label="Switch to dark mode" class=md-option data-md-color-accent=purple data-md-color-media data-md-color-primary=deep-purple data-md-color-scheme=slate id=__palette_0 name=__palette type=radio><label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg></label><input aria-label="Switch to light mode" class=md-option data-md-color-accent=purple data-md-color-media data-md-color-primary=deep-purple data-md-color-scheme=default id=__palette_1 name=__palette type=radio><label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg></label></form><script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script><label class="md-header__button md-icon" for=__search><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg></label><div class=md-search data-md-component=search role=dialog><label class=md-search__overlay for=__search></label><div class=md-search__inner role=search><form class=md-search__form name=search><input aria-label=Поиск autocapitalize=off autocomplete=off autocorrect=off class=md-search__input data-md-component=search-query name=query placeholder=Поиск required spellcheck=false type=text><label class="md-search__icon md-icon" for=__search><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg></label><nav aria-label=Поиск class=md-search__options><a class="md-search__icon md-icon" aria-label=Поделиться data-clipboard data-clipboard-text data-md-component=search-share href=javascript:void(0) tabindex=-1 title=Поделиться> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a><button class="md-search__icon md-icon" aria-label=Очистить tabindex=-1 title=Очистить type=reset><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg></button></nav><div class=md-search__suggest data-md-component=search-suggest></div></form><div class=md-search__output><div class=md-search__scrollwrap data-md-scrollfix><div class=md-search-result data-md-component=search-result><div class=md-search-result__meta>Инициализация поиска</div><ol class=md-search-result__list role=presentation></ol></div></div></div></div></div><div class=md-header__source><a title="Перейти к репозиторию" class=md-source data-md-component=source href=https://github.com/Slava02/Docs> <div class="md-source__icon md-icon"><svg viewbox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="m503.5 204.6-.7-1.8-69.7-181.78c-1.4-3.57-3.9-6.59-7.2-8.64-2.4-1.55-5.1-2.515-8-2.81-2.9-.295-5.7.083-8.4 1.11-2.7 1.02-5.1 2.66-7.1 4.78-1.9 2.12-3.3 4.67-4.1 7.44l-47 144H160.8l-47.1-144c-.8-2.77-2.2-5.31-4.1-7.43-2-2.12-4.4-3.75-7.1-4.77a18.1 18.1 0 0 0-8.38-1.113 18.4 18.4 0 0 0-8.04 2.793 18.09 18.09 0 0 0-7.16 8.64L9.267 202.8l-.724 1.8a129.57 129.57 0 0 0-3.52 82c7.747 26.9 24.047 50.7 46.447 67.6l.27.2.59.4 105.97 79.5 52.6 39.7 32 24.2c3.7 1.9 8.3 4.3 13 4.3 4.7 0 9.3-2.4 13-4.3l32-24.2 52.6-39.7 106.7-79.9.3-.3c22.4-16.9 38.7-40.6 45.6-67.5 8.6-27 7.4-55.8-2.6-82z"/></svg></div> <div class=md-source__repository>Docs</div> </a></div></nav><nav aria-label=Вкладки class=md-tabs data-md-component=tabs><div class=md-grid><ul class=md-tabs__list><li class=md-tabs__item><a class=md-tabs__link href=../../../..> Обзор </a><li class=md-tabs__item><a class=md-tabs__link href=../../../go/concurrency/theory/channels/channels/> Собесы </a></ul></div></nav></header><div class=md-container data-md-component=container><main class=md-main data-md-component=main><div class="md-main__inner md-grid"><div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Навигация data-md-level=0><label class=md-nav__title for=__drawer><a class="md-nav__button md-logo" aria-label=Документация data-md-component=logo href=../../../.. title=Документация> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> Документация</label><div class=md-nav__source><a title="Перейти к репозиторию" class=md-source data-md-component=source href=https://github.com/Slava02/Docs> <div class="md-source__icon md-icon"><svg viewbox="0 0 512 512" xmlns=http://www.w3.org/2000/svg><path d="m503.5 204.6-.7-1.8-69.7-181.78c-1.4-3.57-3.9-6.59-7.2-8.64-2.4-1.55-5.1-2.515-8-2.81-2.9-.295-5.7.083-8.4 1.11-2.7 1.02-5.1 2.66-7.1 4.78-1.9 2.12-3.3 4.67-4.1 7.44l-47 144H160.8l-47.1-144c-.8-2.77-2.2-5.31-4.1-7.43-2-2.12-4.4-3.75-7.1-4.77a18.1 18.1 0 0 0-8.38-1.113 18.4 18.4 0 0 0-8.04 2.793 18.09 18.09 0 0 0-7.16 8.64L9.267 202.8l-.724 1.8a129.57 129.57 0 0 0-3.52 82c7.747 26.9 24.047 50.7 46.447 67.6l.27.2.59.4 105.97 79.5 52.6 39.7 32 24.2c3.7 1.9 8.3 4.3 13 4.3 4.7 0 9.3-2.4 13-4.3l32-24.2 52.6-39.7 106.7-79.9.3-.3c22.4-16.9 38.7-40.6 45.6-67.5 8.6-27 7.4-55.8-2.6-82z"/></svg></div> <div class=md-source__repository>Docs</div> </a></div><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id=__nav_1 type=checkbox> <div class="md-nav__link md-nav__container"><a class=md-nav__link href=../../../..> <span class=md-ellipsis> Обзор </span> </a></div> <nav aria-expanded=false aria-labelledby=__nav_1_label class=md-nav data-md-level=1><label class=md-nav__title for=__nav_1><span class="md-nav__icon md-icon"></span> Обзор</label><ul class=md-nav__list data-md-scrollfix></ul></nav><li class="md-nav__item md-nav__item--section md-nav__item--nested"><input class="md-nav__toggle md-toggle" id=__nav_2 type=checkbox> <label class=md-nav__link for=__nav_2 id=__nav_2_label><span class=md-ellipsis> Собесы </span> <span class="md-nav__icon md-icon"></span></label> <nav aria-expanded=false aria-labelledby=__nav_2_label class=md-nav data-md-level=1><label class=md-nav__title for=__nav_2><span class="md-nav__icon md-icon"></span> Собесы</label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class=md-nav__link href=../../../go/concurrency/theory/channels/channels/> <span class=md-ellipsis> GO </span> <span class="md-nav__icon md-icon"></span> </a><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class=md-nav__link href=../../general/types/> <span class=md-ellipsis> Базы данных </span> <span class="md-nav__icon md-icon"></span> </a><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class=md-nav__link href=../../../systemDesign/api/api/> <span class=md-ellipsis> Системный дизайн </span> <span class="md-nav__icon md-icon"></span> </a><li class="md-nav__item md-nav__item--pruned md-nav__item--nested"><a class=md-nav__link href=../../../screening/hard/> <span class=md-ellipsis> Скрининг </span> <span class="md-nav__icon md-icon"></span> </a></ul></nav></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--secondary" aria-label=Содержание><label class=md-nav__title for=__toc><span class="md-nav__icon md-icon"></span> Содержание</label><ul class=md-nav__list data-md-component=toc data-md-scrollfix><li class=md-nav__item><a class=md-nav__link href=#_2> <span class=md-ellipsis> Что такое кэширование? </span> </a><li class=md-nav__item><a class=md-nav__link href=#_3> <span class=md-ellipsis> Для чего нужно кэширование? </span> </a><li class=md-nav__item><a class=md-nav__link href=#_4> <span class=md-ellipsis> Как работает кэширование? </span> </a> <nav aria-label="Как работает кэширование?" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#_5> <span class=md-ellipsis> Метрики кэша </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#_6> <span class=md-ellipsis> Что можно кэшировать? </span> </a><li class=md-nav__item><a class=md-nav__link href=#_7> <span class=md-ellipsis> Типы кэшей </span> </a><li class=md-nav__item><a class=md-nav__link href=#_8> <span class=md-ellipsis> Стратегии работы с кэшем </span> </a> <nav aria-label="Стратегии работы с кэшем" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#cache-through> <span class=md-ellipsis> Cache through (Сквозное кэширование) </span> </a> <nav aria-label="Cache through (Сквозное кэширование)" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#read-through> <span class=md-ellipsis> Read through (Сквозное чтение) </span> </a><li class=md-nav__item><a class=md-nav__link href=#write-through> <span class=md-ellipsis> Write through (Сквозная запись) </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#cache-aside> <span class=md-ellipsis> Cache aside (Кэширование на стороне) </span> </a> <nav aria-label="Cache aside (Кэширование на стороне)" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#read-aside> <span class=md-ellipsis> Read aside (Чтение на стороне) </span> </a><li class=md-nav__item><a class=md-nav__link href=#write-aside> <span class=md-ellipsis> Write aside (Запись на стороне) </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#cache-ahead> <span class=md-ellipsis> Cache ahead (Опережающие кэширование) </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#_9> <span class=md-ellipsis> Стратегии инвалидации </span> </a> <nav aria-label="Стратегии инвалидации" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#ttl> <span class=md-ellipsis> Инвалидация по TTL </span> </a><li class=md-nav__item><a class=md-nav__link href=#_10> <span class=md-ellipsis> Инвалидация по событию </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#_11> <span class=md-ellipsis> Проблема зависимостей в кэшировании¶ </span> </a><li class=md-nav__item><a class=md-nav__link href=#_12> <span class=md-ellipsis> Стратегии вытеснения </span> </a> <nav aria-label="Стратегии вытеснения" class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#_13> <span class=md-ellipsis> Ничего не делать </span> </a><li class=md-nav__item><a class=md-nav__link href=#random> <span class=md-ellipsis> Random </span> </a><li class=md-nav__item><a class=md-nav__link href=#ttl_1> <span class=md-ellipsis> TTL </span> </a><li class=md-nav__item><a class=md-nav__link href=#lru> <span class=md-ellipsis> LRU </span> </a><li class=md-nav__item><a class=md-nav__link href=#lfu> <span class=md-ellipsis> LFU </span> </a><li class=md-nav__item><a class=md-nav__link href=#second-chance> <span class=md-ellipsis> Second chance </span> </a></ul></nav><li class=md-nav__item><a class=md-nav__link href=#_14> <span class=md-ellipsis> Кэширование ошибок </span> </a><li class=md-nav__item><a class=md-nav__link href=#_15> <span class=md-ellipsis> Заключение </span> </a><li class=md-nav__item><a class=md-nav__link href=#_16> <span class=md-ellipsis> Полезные ссылки </span> </a></ul></nav></div></div></div><div class=md-content data-md-component=content><article class="md-content__inner md-typeset"><h1 id=_1>Кеширование<a title="Permanent link" class=headerlink href=#_1>¶</a></h1><p>Основные термины:<p><strong>Cache miss</strong> Инвалидация промах кэша, запрошенный ключ не был найден в каше<p><strong>Cache Hit</strong> попадание в кэш, запрошенный ключ найден в кэше<p><strong>Hit ratio</strong> процент попаданий запросов в кэш, характеризует эффективность кэширования<p><strong>Горячий ключ</strong> , на который приходится большая часть запросов<p><strong>Прогрев кэша</strong> процесс наполнения кэша данными<p><strong>Инвалиадция</strong> удаление кэшированных данных<h2 id=_2>Что такое кэширование?<a title="Permanent link" class=headerlink href=#_2>¶</a></h2><p>Кэширование – это способ хранения данных как можно ближе к месту их использования. Как правило, для этого используется быстродействующая память (RAM).<h2 id=_3>Для чего нужно кэширование?<a title="Permanent link" class=headerlink href=#_3>¶</a></h2><p>Кэширование появилось давно и использовалось для ускорения работы процессора с оперативной памятью. Наверняка каждый из вас слышал об иерархии кэша L1, L2 и L3, применяемого в процессорах. Добавление кэша значительно ускорило работу с памятью, но и принесло дополнительные проблемы. Самая известная и сложная из них – это <em>инвалидация данных</em>. Мы уделим ей особое внимание чуть позже.<p>С этой проблемой (и рядом других, о которых мы тоже поговорим) связан главный принцип работы с кэшем. Он очень прост: <u>если вы можете обойтись без кэширования, то именно так и сделайте. </u> <p>Например, если у вас простое приложение или небольшая нагрузка, то кэширование вам не нужно. Важно понимать, что кэширование само по себе “<strong>не бесплатное</strong>”, оно привносит в систему дополнительную сложность: появляются дополнительные компоненты, которые надо сопровождать, усложняется структура кода.<p>Но если у вас большая частота запросов (Requests per Second, RPS), если запросы эти “тяжелые ”, если вам слишком дорого масштабировать основное хранилище – любой из этих причин и, тем более, их сочетания достаточно, чтобы задуматься о кэшировании всерьез. При грамотном подходе оно поможет уменьшить в разы время ответа при обращении к данным.<p>Поэтому более продвинутый вариант принципа работы с кэшем можно сформулировать, перефразируя знаменитую цитату немецкого богослова XVIII века Карла Фридриха Этингера: “Дай мне удачу, чтобы без кэша можно было обойтись, дай мне сил, если обойтись без него нельзя – и дай мне мудрости отличить одну ситуацию от другой”.<ul><li>Сокращение response time сервисов<li>Снижение лишней нагрузки на сторонние сервисы<li>Переиспользование ранее полученных или вычисленных данных<li>Стабилизация работы при кратковременных отказах систем</ul><h2 id=_4>Как работает кэширование?<a title="Permanent link" class=headerlink href=#_4>¶</a></h2><p>Логически кэш представляет из себя базу типа ключ-значение. Каждая запись в кэше имеет “время жизни”, по истечении которого она удаляется. Это время называют термином Time To Live или TTL. Размер кэша гораздо меньше, чем у основного хранилища, но этот недостаток компенсируется высокой скоростью доступа к данным. Это достигается за счет размещения кэша в быстродействующей памяти ОЗУ (RAM). Поэтому обычно кэш содержит самые “горячие” данные.<p>Вот самый базовый пример работы кэша:<p><img alt="Пример работы кэша" title="Пример работы кэша" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/ad5/9ad/14b/ad59ad14beb3e26ecee531e25b02c0e2.png><p>Пример работы кэша<p>На первой схеме изображено первое обращение за данными:<ol><li><p>Пользователь запрашивает некие данные</p><li><p>Кэш приложения ПУСТ, поэтому приложение обращается к базе данных (БД)</p><li><p>БД возвращает запрошенные данные приложению</p><li><p>Приложение сохраняет полученные данные в кэше</p><li><p>Пользователь получает данные</p></ol><p>Вторая схема иллюстрирует последующие обращения за данными:<ol><li><p>Пользователь запрашивает данные</p><li><p>Приложение уже имеет эти данные в кэше (ведь они были записаны туда при первом обращении) и поэтому НЕ ОБРАЩАЕТСЯ за ними к БД</p><li><p>Пользователь получает данные</p></ol><p>Из этого простого примера видно, что только первый запрос данных приводит к обращению к БД. Все последующие запросы попадают в кэш до тех пор, пока не истечет TTL. Как только это произойдет, новый запрос снова обращается к БД и заново кэширует данные. Так будет продолжаться все время, пока приложение работает.<p>В результате мы экономим время не только на обработке запросов в БД, но и на сетевом обмене с БД. Все это значительно ускоряет время получения ответа пользователем.<h3 id=_5>Метрики кэша<a title="Permanent link" class=headerlink href=#_5>¶</a></h3><p>Работу кэша можно оценивать при помощи множества метрик разной степени полезности. Я опишу те, которые считаю базовыми и наиболее полезными.<ul><li><p><em>Объем памяти</em>, выделенной под кэш. Это базовый показатель, по которому можно судить, сколько используется ресурсов</p><li><p><em>RPS чтения/записи</em> – количество операций чтения/записи за единицу времени. В обычной ситуации количество операций чтения должно быть в разы больше количества операций записи. Обратное соотношение свидетельствует о проблемах в работе кэша</p><li><p><em>Количество элементов</em> в кэше. Его полезно знать в дополнение к объему памяти, чтобы обнаруживать большие записи</p><li><p><em>Hit rate</em> – процент извлечения данных из кэша. Чем он ближе к 100%, тем лучше. Этот параметр буквально определяет то, насколько наш кэш полезен и эффективен</p><li><p><em>Expired rate</em> – процент удаления записей по истечении TTL. Этот показатель помогает обнаружить проблемы с производительностью, вызванные большим количеством записей с одновременно истекшим TTL</p><li><p><em>Eviction rate</em> – процент вытеснения записей из кэша при достижении лимита используемой памяти. Важный показатель при выборе стратегий вытеснения, о которых мы поговорим чуть позже</p></ul><h2 id=_6>Что можно кэшировать?<a title="Permanent link" class=headerlink href=#_6>¶</a></h2><p>Строго говоря, кэшировать можно что угодно, но не всегда это целесообразно. Все сильно зависит от данных и паттерна их использования.<p>Все данные можно условно разделить на 3 группы по частоте изменений:<ol><li><em>Меняются часто</em>. Такие данные изменяются в течение секунд или нескольких минут. Их кэширование чаще всего бессмысленно, хотя иногда может и пригодится.</ol><p>Пример: ошибки (кэширование ошибок может быть настолько важным, что мы посвятили ему целую главу ближе к концу статьи)<ol><li><em>Меняются нечасто</em>. Такие данные изменяются в течение минут, часов, дней. Именно в этом случае вы чаще всего задаетесь вопросом “Стоит ли мне кэшировать это?”</ol><p>Примеры: списки товаров на сайте, описания товаров<ol><li><em>Меняются крайне редко или не меняются никогда</em>. Такие данные меняются в течение недель, месяцев и лет. В этом случае данные можно спокойно кэшировать. НО! Ни в коем случае нельзя усыплять бдительность верой в то, что какие-либо данные никогда не изменятся. Рано или поздно они изменятся, поэтому всегда выставляйте всем данным разумный TTL. ВСЕГДА!</ol><p>Пример: картинки, DNS<h2 id=_7>Типы кэшей<a title="Permanent link" class=headerlink href=#_7>¶</a></h2><p>С точки зрения архитектуры, можно выделить два типа кэшей: <em>встроенный кэш (inline)</em> и <em>отдельный кэш (sidecar)</em>.<ol><li>Встроенный кэш – это кэш, который “живет” в том же процессе, что и основное приложение. Они делят один сегмент памяти, поэтому за данными можно обращаться напрямую. В качестве такого кэша может выступать map – обычный инструмент из арсенала go – или другие структуры данных (подробнее об этом можно почитать здесь: <a href=https://github.com/hashicorp/golang-lru><u>https://github.com/hashicorp/golang-lru</u></a>). Вот принципиальная схема работы inline cache:</ol><p><img alt="Встроенный кэш (inline)" title="Встроенный кэш (inline)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/ef0/4c9/533/ef04c953311e1b3c7d4ce5defa4f4fc5.png><p>Встроенный кэш (inline)<ol><li>Отдельные кэши (sidecar) – это обособленный процесс со своей выделенной памятью. Как правило, это хранилище типа ключ-значение, которое используется как кэш для основного. Примеры такого типа кэша – Redis, Memcached и другие хранилища типа ключ-значение. Вот принципиальная схема их работы:</ol><p><img alt="Отдельные кэши (sidecar)" title="Отдельные кэши (sidecar)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/8c3/8ae/cc2/8c38aecc23a06e960c2ec6779d5d8366.png><p>Отдельные кэши (sidecar)<p>Сравнение двух типов кэшей:<table><tbody><tr><td><p><strong>Характеристика</strong><td><p><strong>Встроенный кэш (inline)</strong><td><p><strong>Отдельные кэши (sidecar)</strong><tr><td><p>Скорость ответа<td><p>Выше: обращаемся напрямую к памяти<td><p>Ниже: есть сетевые вызовы, а также оверхед на работу самого хранилища<tr><td><p>Память<td><p>Кэш и приложение делят одну область памяти, поэтому ее тратится меньше<td><p>Под кэш выделена отдельная память, поэтому ее тратится больше<tr><td><p>Согласованность данных<td><p>Плохая: каждая копия приложения содержит только свои данные<td><p>Хорошая: все копии приложения обращаются к единому хранилищу<tr><td><p>Масштабирование<td><p>Кэш нельзя масштабировать отдельно от приложения<td><p>Кэш и приложение можно масштабировать независимо друг от друга<tr><td><p>Ресурсы (память, ЦПУ и т.д.)<td><p>Общие, поскольку “живут” в одном процессе<td><p>Выделенные, поскольку “живут” в разных процессах<tr><td><p>Простота сопровождения<td><p>Проще: кэш – просто структура данных, предоставляемая библиотекой<td><p>Сложнее: кэш – отдельно разворачиваемый компонент, требующий отдельного мониторинга и экспертизы<tr><td><p>Изолированность<td><p>Низкая: проводить отдельно работы над кэшем крайне сложно<td><p>Высокая: мы можем проводить любые работы над кэшем независимо от приложения<tr><td><p>Горячий старт<td><p>Сложнее: приложение обычно не общается с диском напрямую<td><p>Проще: например, redis может периодически сбрасывать данные на диск и восстанавливать состояние после рестарта</table><p>Не стоит думать, что один тип кэша хуже другого. У каждого из них свои достоинства и недостатки и каждый из них нужно применять с умом. Более того, их можно комбинировать. Например, вы можете использовать встроенный кэш как L1, а отдельный кэш как L2 перед основным хранилищем. В результате, такая схема может в разы сократить время ответа и снизить нагрузку на основное хранилище.<h2 id=_8>Стратегии работы с кэшем<a title="Permanent link" class=headerlink href=#_8>¶</a></h2><p>Рассмотрим стратегии чтения и записи при работе с кэшем. В приведенных далее примерах кэш может быть как встроенным, так отдельным. Под “приложением” подразумевается некая бизнес-логика. Упор делается на описание взаимодействия компонентов друг с другом.<h3 id=cache-through>Cache through (Сквозное кэширование)<a title="Permanent link" class=headerlink href=#cache-through>¶</a></h3><p>В рамках этой этой стратегии все запросы от приложения проходят через кэш. В коде это может выглядеть как связующее звено или “декоратор” над основным хранилищем. Таким образом, для приложения кэш и основная БД выглядят как один компонент хранилища.<h4 id=read-through>Read through (Сквозное чтение)<a title="Permanent link" class=headerlink href=#read-through>¶</a></h4><p><img alt="Read through (Сквозное чтение)" title="Read through (Сквозное чтение)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/32a/18d/4cc/32a18d4cc27f7adf65d94bdf403eca36.png><p>Read through (Сквозное чтение)<ol><li><p>Приходит запрос на получение данных</p><li><p>Пытаемся прочитать данные из кэша</p><li><p>В кэше нужных данных нет, происходит промах (miss)</p><li><p>Кэш перенаправляет запрос в БД. Это важный нюанс стратегии: к БД обращается именно кэш, а не приложение</p><li><p>Хранилище отдает данные</p><li><p>Сохраняем данные в кэш</p><li><p>Отдаем запрошенные данные приложению. Для приложения это выглядит так, как если бы хранилище просто вернуло ему данные, то есть шаги 3-6 скрыты от основной бизнес-логики</p><li><p>Возвращаем результат запроса</p></ol><h4 id=write-through>Write through (Сквозная запись)<a title="Permanent link" class=headerlink href=#write-through>¶</a></h4><p><img alt="Write through (Сквозная запись)" title="Write through (Сквозная запись)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/1ff/396/8bd/1ff3968bda1e513447463ebb1cb46bba.png><p>Write through (Сквозная запись)<ol><li><p>Приходит запрос на вставку каких-либо данных</p><li><p>Отправляем запрос на запись через кэш. В этот момент кэш выступает только как прокси и сам по себе ничего не делает</p><li><p>Сохраняем данные в БД</p><li><p>БД возвращает результат запроса</p><li><p>Сохраняем данные в кэш. Делаем мы это специально после вставки, чтобы кэш и БД были консистентны. Если бы мы писали данные в кэш на шаге 2, а при этом на шаге 3 произошла бы ошибка, то кэш содержал бы данные, которых нет в БД, что может привести к печальным последствиям</p><li><p>Отдаем запрошенные данные приложению</p><li><p>Возвращаем результат запроса</p></ol><p>Преимущества:<ul><li><p>Очень простая схема работы с точки зрения организации кода</p><li><p>В коде легко добавить/убрать кэш, так как обычно это простая “обертка” над основным хранилищем</p></ul><p>Недостатки:<ul><li>Схема негибкая, поскольку записывать в кэш мы можем строго после выполнения основного запроса и в целом кэш скрыт от бизнес-логики</ul><h3 id=cache-aside>Cache aside (Кэширование на стороне)<a title="Permanent link" class=headerlink href=#cache-aside>¶</a></h3><p>В этой стратегии, приложение координирует запросы в кэш и БД и само решает, куда и в какой момент нужно обращаться. В коде это выглядит как два хранилища: одно постоянное, второе – временное.<h4 id=read-aside>Read aside (Чтение на стороне)<a title="Permanent link" class=headerlink href=#read-aside>¶</a></h4><p><img alt="Read aside (Чтение на стороне)" title="Read aside (Чтение на стороне)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/f4e/034/5f6/f4e0345f69cbabe1c7fef63e0b0b5efa.png><p>Read aside (Чтение на стороне)<ol><li><p>Приходит запрос на получение данных</p><li><p>Пытаемся читать из кэша</p><li><p>В кэше нужных данных нет, происходит промах (miss)</p><li><p>Приложение само обращается к хранилищу. В этом главное отличие от сквозного подхода: бизнес-логика в любой момент времени сама решает, куда обращаться – к кэшу или к БД</p><li><p>БД отдает данные</p><li><p>Сохраняем данные в кэш</p><li><p>Возвращаем результат запроса</p></ol><h4 id=write-aside>Write aside (Запись на стороне)<a title="Permanent link" class=headerlink href=#write-aside>¶</a></h4><p><img alt="Write aside (Запись на стороне)" title="Write aside (Запись на стороне)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/16d/9a4/af1/16d9a4af1917242c969b4f4cc01771e0.png><p>Write aside (Запись на стороне)<ol><li><p>Приходит запрос на вставку каких-либо данных</p><li><p>Сохраняем данные в БД</p><li><p>БД возвращает результат запроса</p><li><p>Сохраняем данные в кэш. Опять-таки, мы намеренно делаем это после вставки, чтобы кэш и БД были консистентны. Сохранение данных в кэше перед шагом 2 и ошибка на шаге 2 привели бы к появлению в кэше данных, которых нет в БД. Результат был бы все тот же – печальные последствия</p><li><p>Возвращаем результат запроса</p></ol><p>Преимущества:<ul><li>Гибкость. Управление полностью в руках приложения. Оно может сохранить данные в кэш сразу после обращения к БД, а может предварительно сделать еще ряд манипуляций с данными и только затем сохранить их в БД</ul><p>Недостатки:<ul><li><p>Схема работы немного сложнее с точки зрения организации кода</p><li><p>В коде сложнее добавить/убрать кэш, поскольку это отдельный компонент, с которым взаимодействует бизнес-логика. Изменить этого взаимодействие может быть сложно</p></ul><h3 id=cache-ahead>Cache ahead (Опережающие кэширование)<a title="Permanent link" class=headerlink href=#cache-ahead>¶</a></h3><p>Эта стратегия предназначена только для запросов на чтение. Они <strong>всегда идут только</strong> в кэш, никогда не попадая в БД напрямую. По факту мы работаем со снимком состояния БД и обновляем его с некоторой периодичностью. Для приложения это выглядит просто как хранилище, как и в случае со сквозным кэшированием.<p><img alt="Cache ahead (Опережающие кэширование)" title="Cache ahead (Опережающие кэширование)" src=https://habrastorage.org/r/w1560/getpro/habr/upload_files/737/df2/c61/737df2c61d03b05596f070f51560ea14.png><p>Cache ahead (Опережающие кэширование)<ol><li><p>Входящие запросы на чтение:</p> <ol><li><p>Приходит запрос на получение данных</p><li><p>Читаем из кэша. Если в кэше нет нужных данных, то возвращаем ошибку. К БД в случае промаха не обращаемся</p><li><p>Если данные есть, то отдаем их приложению</p><li><p>Возвращаем результат запроса</p></ol><li><p>Обновление кэша:</p> <ol><li><p>Периодически запускается фоновый процесс, который читает данные из БД.</p><li><p>Читаем актуальные данные из БД</p><li><p>БД отдает данные</p><li><p>Сохраняем данные в кэш</p></ol></ol><p>Преимущества:<ul><li><p>Минимальная и полностью контролируемая нагрузка на БД. Клиентские запросы не могут повлиять на БД</p><li><p>В коде легко добавить/убрать кэш, поскольку можно просто заменить кэш на основное хранилище и обращаться уже к нему</p><li><p>Простота, так как не приходится иметь дело с двумя хранилищами</p></ul><p>Недостатки:<ul><li>Кэш отстает от основного хранилища на период между запусками обновления кэша. Нужно помнить, что на момент обращения свежие данные могут еще “не доехать” до кэша. Эта проблема может быть решена использованием сквозной записи или записи на стороне. Тогда, при обновлении данных в БД, данные будут обновляться и в кэше</ul><p>Вы можете использовать описанные стратегии в любых комбинациях. Например, вы можете взять опережающие кэширование, добавить туда сквозную запись и чтение на стороне, чтобы добиться максимальный актуальности данных и избежать промахов по максимуму!<h2 id=_9>Стратегии инвалидации<a title="Permanent link" class=headerlink href=#_9>¶</a></h2><p>Инвалидация – это процесс удаления данных из кэша или пометка их как недействительных. Делается это для того, чтобы гарантировать актуальность данных, с которыми работает приложение.<h3 id=ttl>Инвалидация по TTL<a title="Permanent link" class=headerlink href=#ttl>¶</a></h3><p><strong>TTL (Time To Live)</strong> – время жизни данных в кэше. При сохранении данных в кэш для них устанавливается TTL и данные будут обновляться с периодичностью не менее TTL. <p>Это самый простой способ инвалидации данных. Тем не менее, у этой стратегии есть свои подводные камни.<p>Самый главный из них – вопрос длительности TTL. Если TTL слишком короткий, то запись может “протухнуть” и стать недействительной раньше, чем обновление было бы необходимо, что приведет к отправке повторного запроса в источник данных. Если TTL слишком длинный, то запись может содержать устаревшие данные, что может привести к ошибкам или неправильной работе приложения. Обычно ответ на этот вопрос подбирается эмпирическим путем. <p>Есть, впрочем, и другой вариант. Источник данных может присылать TTL сам, тогда клиенту не придется выбирать TTL, а просто брать предлагаемый. Такой подход, например, можно использовать в HTTP.<p>Сложность иного рода возникает, если записи становятся недействительными одновременно в большом количестве. В таком случае возникает множество запросов в источник данных, что может привести к проблемам с производительностью, а то и вовсе “положить” его. Для избежания подобной ситуации, можно использовать jitter.<p><strong>Jitter</strong> – это случайное значение, добавляемое к TTL. Если в обычном случае все записи имеют, например, TTL = 60 сек., то при использовании jitter с диапазоном от 0 до 10 сек. TTL будет принимать значение от 60 до 70 сек. Это позволит сгладить количество записей, переходящих в состояние недействительных одновременно.<p>Jitter позволил нам сгладить нагрузку на источник данных, когда “протухает” много записей сразу. Но что делать, если есть одна запись, которую интенсивно используют? Ее инвалидация приведет к тому, что все запросы, которые не нашли данных в кэше, одновременно обратятся к источнику. Тогда нам нужно схлопнуть все эти запросы в один. В go есть для этого отличная библиотека <a href=https://pkg.go.dev/golang.org/x/sync/singleflight><u>singleflight</u></a>. Она определяет одинаковые запросы, возникающие одномоментно, выполняет лишь один запрос в источник, а затем отдает результат всем изначальным запросам. Таким образом, если у нас возникли десять запросов, библиотека выполнит только один из них, а результат вернет всем десяти. Стоит отметить, что эта библиотека работает только в рамках одного экземпляра приложения. Если у вас их несколько, то даже с использованием этой библиотеки в источник может уйти больше одного запроса.<h3 id=_10>Инвалидация по событию<a title="Permanent link" class=headerlink href=#_10>¶</a></h3><p>При таком подходе данные инвалидируют при наступлении некоего события – обычно это обновление данных в источнике. На самом деле, мы уже рассмотрели этот способ, когда говорили про стратегии использования кэширования, а именно write through и write aside.<p>Также в качестве события для инвалидации данных может выступать время последней модификации данных. Такой способ используется в HTTP.<h2 id=_11>Проблема зависимостей в кэшировании¶<a title="Permanent link" class=headerlink href=#_11>¶</a></h2><p>При редактировании данных, необходимо удалить также и все кэши, содержащие данные этой модели. Например, при редактировании продукта, который присутствует на закэшированной главной странице компании, требуется инвалидировать и ее кэш тоже. Другой случай, - обновляя данные пользователя (например, фамилию), мы должны также удалить все кэши страниц его постов, на которых присутствуют обновленные данные.<p>Обычно за инвалидацию кэша отвечает паттерн Observer, или его разновидность - паттерн Multicast. Но даже в этом случае механизмы инвалидации получаются слишком сложными, достигаемая точность слишком низкая, a код обрастает лишним сопряжением и зачастую жертвует своей инкапсуляцией.<p>И тут на выручку приходит тегирование кэша, т.е. прошивание кэша метками. Например, кэш главной страницы может быть прошит тегом product.id:635. А все посты пользователя могут быть прошиты меткой user.id:10. Коллекции можно кэшировать составным тегом, состоящим из критериев выборки, например type.id:1;category.id:15;region.id:239.<p>Теперь достаточно инвалидировать метку, чтобы все зависимые кэши автоматически инвалидировались.<ul><li>https://dev.to/abvarun226/caching-records-by-tags-in-go-36ia</ul><h2 id=_12>Стратегии вытеснения<a title="Permanent link" class=headerlink href=#_12>¶</a></h2><p>Размер кэша ограничен, он гораздо меньше основного хранилища, а значит, мы не может разместить в нем все данные. Что делать, когда память, выделенная под кэш, полностью заполнена, а новые записи продолжают поступать?<h3 id=_13>Ничего не делать<a title="Permanent link" class=headerlink href=#_13>¶</a></h3><p>Конечно, можно игнорировать все новые записи и ждать, пока существующие истекут по TTL. Однако в общем случае это крайне неэффективно, поскольку все запросы идут в источник данных и все преимущества кэша нивелируются. Поэтому обычно используются более эффективные стратегии вытеснения.<h3 id=random>Random<a title="Permanent link" class=headerlink href=#random>¶</a></h3><p><strong>Random</strong> – стратегия вытеснения, при которой удаляются случайные записи. Это самая простая стратегия: просто удаляем то, что первым попалось под руку. Но этот способ недалеко ушел от стратегии “ничего не делать”.<h3 id=ttl_1>TTL<a title="Permanent link" class=headerlink href=#ttl_1>¶</a></h3><p><strong>TTL</strong> – стратегия вытеснения, предусматривающая удаление той записи, которой осталось меньше всего “жить”, то есть у которой TTL истечет раньше всех. Как и random, эта стратегия немного лучше, чем “ничего не делать”, но все еще недостаточно эффективна.<h3 id=lru>LRU<a title="Permanent link" class=headerlink href=#lru>¶</a></h3><p><strong>LRU (Least Recently Used)</strong> – стратегия вытеснения, которая опирается на время последнего использования записи. Она удаляет записи, у которых время последнего использования старше остальных. Таким образом, в кэше остаются записи, которые использовались недавно. Эта стратегия опирается уже не на случай, а на паттерн использования данных, поэтому она гораздо эффективнее предыдущих.<p>Эта стратегия хорошо подходит, когда:<ul><li><p>недавно использованные данные, скорее всего, будут использованы снова в ближайшем будущем</p><li><p>нет данных, которые используются чаще остальных</p><li><p>вы не знаете, что именно вам нужно</p></ul><h3 id=lfu>LFU<a title="Permanent link" class=headerlink href=#lfu>¶</a></h3><p><strong>LFU (Least Frequently Used)</strong> – стратегия вытеснения, опирающаяся на частоту использования записи. Она удаляет записи, которые использовались реже всего. Так в кэше остаются данные, которые использовались чаще других. Эта стратегия тоже опирается не на случай, а на паттерн использования данных, поэтому она тоже эффективнее остальных и является альтернативой LRU.<p>Эта стратегия хорошо подходит, когда есть данные, которые используются значительно чаще остальных. Такие данные разумно не вытеснять из кэша, чтобы избежать лишних “походов” в источник.<h3 id=second-chance>Second chance<a title="Permanent link" class=headerlink href=#second-chance>¶</a></h3><p>При обращении выставляем бит присут<h2 id=_14>Кэширование ошибок<a title="Permanent link" class=headerlink href=#_14>¶</a></h2><p>Ранее я упомянул, что мы можем кэшировать ошибки. На первый взгляд это может показаться странным: зачем нам вообще кэшировать ошибки? На самом деле, это крайне полезная штука.<p>Представим себе, что клиент запрашивает данные, которых нет в источнике. Пусть это будем информация о товаре по id. Казалось бы, нет данных и ладно: просто сходим в источник, ничего не получим и сообщим клиенту. Но что, если таких запросов много? А что, если кто-то делает это специально?<p>Это типичная схема так называемой атаки через промахи кэша (<strong>cache miss attack</strong>). Ее суть в запрашивании данных, которых заведомо не может быть в кэше, поскольку их нет в источнике. Вал таких запросов может привести к проблемам с производительностью источника и даже к его “падению”. Этого можно избежать, если кэшировать ошибку, тогда последующие запросы того же рода будут попадать в кэш и источник не пострадает.<p>Но тут тоже нужно быть осторожным. Если хранить в одном кэше и полезные данные, и ошибки, то в случае атаки полезные данные могут вытеснены из кэша. Поэтому я бы рекомендовал иметь выделенный кэш под ошибки. Он может быть меньшего объема, чем основной кэш.<p>Также кэширование ошибок полезно, если сервис, к которому вы обращаетесь, “почувствовал себя плохо”. Чтобы не забивать его запросами, которые, скорее всего, не будут выполнены, а лишь усугубят проблему, лучше кэшировать ошибки на несколько секунд. Таким образом, мы перестанем оказывать негативное воздействие на сервис и дадим ему возможность нормализоваться. Но с этой задачей лучше справляется паттерн <strong>Circuit Breaker</strong>, который мы не будем рассматривать в рамках этой статьи.<h2 id=_15>Заключение<a title="Permanent link" class=headerlink href=#_15>¶</a></h2><p>На этом пока все. Я не ставил перед собой целью раскрыть тему кэширования исчерпывающе: наверняка многие вещи остались не рассмотренными в рамках этой статьи. Я хотел лишь предоставить структурированную основу и хочу верить, что у меня это получилось.<p>Надеюсь, данный материал оказался вам полезен, вы открыли для себя что-то новое или структурировали уже известное.<h2 id=_16>Полезные ссылки<a title="Permanent link" class=headerlink href=#_16>¶</a></h2><ul><li><p><a href=https://redis.io/docs/reference/eviction/>О стратегиях вытеснения на примере инструментов redis</a></p><li><p><a href=https://aws.amazon.com/builders-library/caching-challenges-and-strategies/>Трудности и стратегии кэширования на сайте Amazon</a></p><li><p><a href=https://aws.amazon.com/ru/caching/>Основы кэширования от Amazon</a></p><li><p><a href=https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88>Базовый “ликбез” и ссылки на первоисточники от Wikipedia</a></p></ul><aside class=md-source-file><span class=md-source-file__fact> <span title="Последнее обновление" class=md-icon> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="14 марта 2025 г. 09:17:45">14 марта 2025 г. 09:17:45</span> </span><span class=md-source-file__fact> <span title="Дата создания" class=md-icon> <svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg> </span> <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="14 марта 2025 г. 09:17:45">14 марта 2025 г. 09:17:45</span> </span></aside></article></div><script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script></div><button class="md-top md-icon" data-md-component=top hidden type=button><svg viewbox="0 0 24 24" xmlns=http://www.w3.org/2000/svg><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> К началу</button></main><footer class=md-footer><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class=md-copyright>Made with <a href=https://squidfunk.github.io/mkdocs-material/ rel=noopener target=_blank> Material for MkDocs </a></div></div></div></footer></div><div class=md-dialog data-md-component=dialog><div class="md-dialog__inner md-typeset"></div></div><script id=__config type=application/json>{"base": "../../../..", "features": ["navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.top", "navigation.indexes", "navigation.prune", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.tooltips"], "search": "../../../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "\u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0432 \u0431\u0443\u0444\u0435\u0440", "clipboard.copy": "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440", "search.result.more.one": "\u0415\u0449\u0451 1 \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.more.other": "\u0415\u0449\u0451 # \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.none": "\u0421\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e", "search.result.one": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e 1 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435", "search.result.other": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439: #", "search.result.placeholder": "\u041d\u0430\u0447\u043d\u0438\u0442\u0435 \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430", "search.result.term.missing": "\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442", "select.version": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0435\u0440\u0441\u0438\u044e"}}</script><script src=../../../../assets/javascripts/bundle.d7c377c4.min.js></script>