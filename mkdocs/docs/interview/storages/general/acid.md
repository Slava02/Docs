# Транзакция 

****Транзакцией называется множество операций, которые переводят базу данных из одного корректного состояния в другое корректное состояние (согласованность) при условии, что транзакция выполнена полностью (атомарность) и без помех со стороны других транзакций (изоляция).****

Согласованность:
Всем известно, что реалиционных СУБД сущесвтвуют ограничения целостности данных и СУБД ответственно следит за тем, чтобы они никогда не нарушались.

Атомарность:
Но некоторые условия слишком сложны для того, чтобы быть понятыми СУБД и могут нарушать согласованность (корректность) данных, не нарушая при этом целостности.
Обычно за согласованностью данных следит клиентское приложение, но иногда возникают ситуации, когда промежуточная операция приводит базу в несогласованное состояние и это нормально! (перевод денег)
В таких случаях, важно не зависнуть на этом промежуточном шаге и отменить изменения. С этим как раз и помогает СУБД, если, конечно, знает, что эти операции представляют собой неделимое целое.

Изолированность:
Есть и более тонкий момент - транзакции абсолютно правильные сами по себе, при одновременном выполнении, могут начать барахлить. Такие ситуации называются аномалиями.
Простой пример - если приложение хочет получить данные, то оно должно, как минимум, не видить незаификсированные изменения других транзакций. Иначе, если какая-то транзакция отменится, можно получить состояние, в котором база данных никогда и не была (грязное чтение)
Роль СУБД как раз в том, чтобы выполнять транзакци параллельно и при этом гарантировать, что результат такого выполнения будет совпадать с результатом одного из возможных последовательных выполнений.


Всего в стандарте SQL выделяют 4 уровня изоляции, каждый из которых определяется перечеслением аномалий, которые допускаются или не допускаются при одновременном выполнении транзакций.

**Грязное чтение и Read Uncommitted**

Возникает, когда транзакция читает еще не зафиксированные изменения, сделанные другой транзакцией

**Неповторяющееся чтение и Read Committed**

Аномалия неповторяющегося чтения (non-repeatable read) возникает, когда транзакция читает одну и ту же строку два раза, а в промежутке между чтениями вторая транзакция изменяет (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит разные результаты.

**Фантомное чтение и Repeatable Read**

Аномалия фантомного чтения (phantom read) возникает, когда одна транзакция два раза читает набор строк по одинаковому условию, а в промежутке между чтениями другая транзакция добавляет строки, удовлетворяющие этому условию, и фиксирует изменения. Тогда первая транзакция получит разные наборы строк.

**Отсутствие аномалий и Serializable**

Уровень, на котором не допускаются никакие аномалии. Чем отличается от repeatable read? Да все просто - он, конечно, снимает все описанные в стандарте аномалии, но не все известные практике и науке. В частности, еще остаются:
- Несогласованная запись 
- Аномалия только читающей транзакции

Serializable реализован как надстройка над изоляцией на основе снимков данных. Те аномалии, которые не возникают при Repeatable Read (такие как грязное, неповторяемое, фантомное чтение), не возникают и на уровне Serializable. А те две аномалии, которые возникают (несогласованная запись и аномалия только читающей транзакции), специальным образом обнаруживаются, и в этом случае транзакция обрывается: возникает уже знакомая нам ошибка сериализации

Итого:
![img.png](imgs/img.png)

**Уровни изоляции в PostgreSQL**

Со временем на смену блокировочным протоколам управления транзакциями пришел протокол изоляции на основе снимков (Snapshot Isolation, SI). В PostgreSQL реализован многоверсионный вариант протокола SI

За счет использования снимков данных изоляция в PostgreSQL отличается от той, что требует стандарт, и в целом она строже.

![img_1.png](imgs/img_1.png)


# Уровень изоляции Read committed

Уровень изоляции по умолчанию в Постгре. При нем, команда обновления может увидеть несогласованное состояние: она может видеть результаты параллельных команд, изменяющих те же строки, что пытается изменить она, но при этом не видит результаты этих команд в других строках таблиц. Такое поведение делает режим Read committed непригодным для команд, включающих сложные условия поиска.
- начали новую транзакцию в двух сессиях
- в первой сессии добавить новую запись
```bash
wb=*# insert into slava.test values (2);
INSERT 0 1
```
- делаем запрос на выбор всех записей во второй сессии
```bash
wb=*# select * from slava.test;
 i
---
 1
(1)
```
Не видим изменений, так как  при уровне изоляции read committed - транзакции видят только подтвержденные изменения других транзакций, а мы еще не завершили транзакцию с изменением.
- завершаем транзакцию в первом окне
```bash
wb=*# COMMIT;
COMMI
```
- делаем запрос на выбор всех записей второй сессии
```bash
wb=*# SELECT * FROM slava.test;
 i
---
 1
 2
(2 rows)
```
Видим изменения, так как теперь изменение считается подтвержденным.

## Уровень изоляции Repeatable read

Режим Repeatable read обеспечивает строгую гарантию того, что каждая транзакция видит полностью стабильное представление базы данных. Однако это представление не обязательно всегда будет соответствовать некоторому последовательному выполнению параллельных транзакций одного и того же уровня. Уровень изоляции Repeatable read реализуется с использованием метода, известного как **Изоляция снепшотов (snapshot isolation)**

- начали новую транзакцию в двух сессиях с уровнем изоляции Repeatable read
```bash
wb=*# BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN
```
- в первой сессии добавить новую запись
```bash
wb=*# insert into slava.test values (3);
INSERT 0 1
```
- делаем запрос на выбор всех записей во второй сессии
```bash
wb=*# select * from slava.test;
 i
---
 1
 2
(2 rows)
```
Не видим изменений, так как  при уровне изоляции read committed - транзакции видят только подтвержденные изменения других транзакций, а мы еще не завершили транзакцию с изменением.
- завершаем транзакцию в первом окне
```bash
wb=*# COMMIT;
COMMI
```
- делаем запрос на выбор всех записей второй сессии
```bash
wb=*# SELECT * FROM slava.test;
 i
---
 1
 2
(2 rows)
```
Не вижу изменения, так как новая запись появилась после момента начала транзакции.

## Уровень изоляции Serializable[](https://docs.arenadata.io/ru/ADPG/current/concept/concurrency-control/transaction-isolation-lvls.html#%D1%83%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C-%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%B8-serializable)

Уровень изоляции Serializable обеспечивает самую строгую изоляцию транзакций. Этот уровень эмулирует последовательное выполнение транзакций для всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не одновременно.