# Вопросы

??? question "Чем отличается TCP от UDP?"

    TCP-протокол по аналогии с почтой можно представить так: нам нужно отправлять три тома «Войны и мира», для этого нужно не менее 200 конвертов. Но тут свои коррективы вносит «Почта России»: какие-то из писем уедут на сортировочный пункт в Хабаровск, а какие-то из писем и вовсе могут потеряться в кипах посылок.

    Мы нумеруем наши конверты, чтобы точно знать, какие мы уже получили, а какие надо подождать или попросить отправить заново. Конверты уходят, получатель получает какую-то их часть. Потом он звонит нам: «Отправь заново конверты 12, 48 и 110, они не дошли». Мы отправляем. Получатель снова звонит: «Вот, теперь всё получил».

    А вот протокол UDP — это протокол без гарантии: конверты просто улетели. Что дошло,  то дошло. Можно представить так: мы попросили рассказать «Войну и мир» здесь и сейчас. Рассказывающий будет забывать большие куски повествования, где-то будет сокращать, но в целом суть истории мы узнаем и требовать дословного пересказа не будем.

    Протокол TCP, таким образом, используется при отправке файлов, почты, при работе веб-серверов: там, где требуется гарантировать корректность переданных данных. А протокол UDP подходит для потоковых данных: аудио- или видеозвонки, потоковое видео, стриминги и прочее. Если какие-то пакеты потеряются, то качество может незначительно ухудшиться, но смысл останется понятным, а времени восстанавливать эти потерянные пакеты у нас может не быть в случае онлайн-стриминга.

??? question "Какие метрики для мониторинга приложений используют?"

    LTES

    - Latency - время на обработку одного запроса
    - Traffic - количество запросов
    - Errors - количество ошибок
    - Saturation - насколько компонент использует свои ресурсы

    ![LTES](./assets/img.png)

??? question "Чем отличается процесс от потока?"
    Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

    Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

    Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

??? question "Напишите функцию, которая возвращала бы ошибку, не импортируя при этом никаких пакетов"
    
    === "Условие"
        ```go
        package main

        func main() {
            println(handle())
        }

        func handle() error {
            
        }
        ```
    
    === "Решение"
        ```go
        package main

        type MyError string

        func (e MyError) Error() string {
            return string(e)
        }

        func main() {
            println(handle())
        }

        func handle() error {
            return MyError("ERROR")
        }
        ```
    
    === "Объяснение"
        В решении мы создаем пользовательский тип ошибки `MyError`, который реализует интерфейс `error`. 
        Для этого достаточно реализовать метод `Error() string`. 
        В функции `handle()` мы возвращаем значение типа `MyError`, которое автоматически преобразуется в интерфейс `error`.

??? question "Требуется реализовать функцию uniqRand, которая генерирует слайс длины n уникальных, рандомных чисел"
    
    === "Условие"
        ```go
        package main

        import (
            "fmt"
        )

        // uniqRandn генерирует слайс длины n уникальных случайных чисел в диапазоне от 0 до 100.
        func uniqRandn(n int) []int {
        }

        func main() {
            n := 10 // Количество уникальных чисел

            randomNumbers := uniqRandn(n)
            fmt.Println(randomNumbers)
        }
        ```
    
    === "Решение"
        ```go
        package main

        import (
            "fmt"
            "math/rand"
            "time"
        )

        // uniqRandn генерирует слайс длины n уникальных случайных чисел в диапазоне от 0 до 100.
        func uniqRandn(n int) []int {
            randomNumbers := make([]int, 0, n)
            used := make(map[int]struct{})

            rand.Seed(time.Now().UnixMilli())

            for len(randomNumbers) < n {
                num := rand.Int()
                if _, ok := used[num]; !ok {
                    used[num] = struct{}{}
                    randomNumbers = append(randomNumbers, num)
                }
            }

            return randomNumbers
        }

        func main() {
            n := 10 // Количество уникальных чисел

            randomNumbers := uniqRandn(n)
            fmt.Println(randomNumbers)
        }
        ```
    
    === "Объяснение"
        В решении мы используем map для отслеживания уже использованных чисел. 
        Это позволяет нам гарантировать уникальность каждого числа в результирующем слайсе.
        Мы инициализируем слайс с начальной емкостью n для оптимизации памяти.
        Используем `rand.Seed()` для инициализации генератора случайных чисел текущим временем.
        В цикле генерируем случайные числа, пока не получим n уникальных значений.

??? question "Необходимо построить оптимальный индекс для запроса"
    
    === "Условие"
        ```sql
        SELECT * FROM employee 
        WHERE sex = 'm' 
          AND salary > 30000 
          AND age = 20 
        ORDER BY created_at;
        ```
    
    === "Решение"
        ```sql
        CREATE INDEX idx ON employee (sex, salary, age);
        ```
    
    === "Объяснение"
        В этом запросе используется фильтрация по трем колонкам (`sex`, `salary`, `age`) и сортировка по `created_at`. 
        Поэтому оптимальным индексом будет индекс, включающий все эти колонки. 
        Такой индекс позволит:
        1. Сначала отфильтровать строки по условиям
        2. Затем отсортировать их по `created_at`
        
        Порядок колонок в индексе важен:
        - `sex` идет первым, так как это точное совпадение
        - `salary` и `age` идут далее, так как это диапазонные условия

